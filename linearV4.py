import cProfile, copy, time

#Gets unique combinations of sublists from a list
def pickSublists(nList, groupNumber, index=0, level=1):
	items = []
	if level != groupNumber:
		for n in range(index, len(nList)):
			for s in pickSublists(nList, groupNumber, n+1, level + 1):
				temp = s + [nList[n]]
				found = False
				for i in items:
					if recurseCheck(temp, i):
						found = True
						break

				if not found:
					items.append(temp)
	else:
		for n in range(index, len(nList)):
			items.append([nList[n]])
	
	return items

#Compares two complex lists of equal number of elements
def recurseCheck(listA, listB):
	if listA == 1 or listB == 1:
		return listA == listB
	else:
		goal = len(listA)
		#If the number of items in the outer most list aren't equal then don't bother going deeper
		if goal != len(listB):
			return False
	
		tempB = listB[:]
		for a in listA:
			found = False
			for b in range(goal):
				if recurseCheck(a, tempB[b]):
					found = True
					del tempB[b]
					goal -= 1
					break

			#If no items in listB match an element in listA then just quit since we didn't match all elements
			if not found:
				return False

		return True

#The mainline keeps track of attempts made by higher levels
#In earlier iterations of the algorithm this was insufficient to filter out all duplicates however that doesn't seem to be the case anymore
def groupRecurse(nList, mainLine = []):
	groupList = []
	nLen = len(nList)
	#Group up elements into subgroups of increasing size of length = groupNumber
	for groupNumber in range(2, nLen):
		#Loop through all unique sub-lists that can be generated from the given nList
		for sub in pickSublists(nList, groupNumber):
			#We need a copy because we will delete the indexes used in the group
			tempCopy = nList[:]
			#For each unique sublist, combine it with our nList while stripping out the elements we combined
			count = 0
			
			#Sub represents a combination of elements from nList generated by pickSublists
			#We will delete out the element used to make Sub from our copy of nList and then we will reattach them in the form of sub
			#Example: nlist = [1, 1, [1, [1, 1]]] sub = [1, [1, [1, 1]]] tempCopy after delete = [1] tempCopy after attach = [1, [1, [1, [1, 1]]]]
			for item in sub:
				#Delete identical items from our copy of nList
				for i in range(nLen - count):
					if recurseCheck(tempCopy[i], item):
						count += 1
						del tempCopy[i]
						break

			#Append the sublist of elements we just deleted
			tempCopy.append(sub)
			
			#Only compare items from the mainline that have the same number of items as the resulting new configuration
			#if tempCopy not in mainLine:
			found = False
			for main in mainLine:
				if recurseCheck(main, tempCopy):
					found = True
					break

			if not found:
				groupList.append(tempCopy)
				#Recurse
				groupList.extend(groupRecurse(tempCopy, mainLine + groupList))
			
	return groupList

def main():
	n = int(input("Number of resistors: "))
	pList = [1] * n
	startTime = time.time()
	totalList = [pList] + groupRecurse(pList)

	print("Configs: " + str(2 * len(totalList)))
	print("Time: " + str(time.time() - startTime))

	return totalList

main()
#cProfile.run("main()")